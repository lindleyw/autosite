#!/usr/bin/perl

# makeindex.pl
# 
# 	$Id: autothumb.pl,v 1.3 2005/03/25 17:13:42 bill Exp $
#
# Copyright (c) 2003, wlindley.com, l.l.c.  Scottsdale, AZ  www.wlindley.com
#
# ls *.jpg | ./makeindex.pl -c 3 > index.html
#    makes an index file in 3-column table format,
#    putting thumbnails in the thumb/ directory.
# ls *.jpg | ./makeindex.pl -s -p 65536 > index.html
#    makes an index file in 1-column unordered list format,
#    putting medium-sized pictures of <= 64K pixels in the med/ directory
#    and thumbnails in the thumb/ directory.
#    (Default for -s without -p is equivalent to 640x480)
# ./makeindex.pl
#    Uses IMAGES list and all settings from index.txt
#
# -t dir/    name thumbnail directory
# -m dir/    name 'medium' image directory
# -c n       set number of columns
# -p n       make 'medium' pictures no larger than 'n' pixels total
# -s         make 'medium' Sized pictures
# -S         make 'medium' Sized pictures for thumbnails, full sized for links
# -T n       limit thumbnails to n-by-n pixels (default: 64)
# -u tfile   use template file and look for text files for each picture.
#            also disables "nnn files, totaling nnn bytes"

#
# where sizes can be:
#   250000    250,000 pixels maximum (e.g., 500x500)
#   x100x100  exactly 100x100 pixels (may distort image)
#   b200x200  Bounding box 200x200 (limits X and Y to fit within)
#

#
# index.txt is read, and should be formatted with:
#
#  THUMB:       0 or 1         # whether to produce thumbnails  
#  THUMB.SIZE:  n or  100x100  # sets maximum pixel count, or maximum x,y size 
#  THUMB.DIR:   thumbdir/      # thumbnail directory
#  MEDIUM:      0 or 1         # whether to produce medium size pictures
#  MEDIUM.SIZE: n or  100x100  # sets maximum pixel count, or maximum x,y size
#  MEDIUM.DIR:  meddir/        # medium picture directory
#  LIST.TYPE:                  # 'p' for each image in its own paragraph
#                              # 'table' for multicolumn table
#                              # 'ul' for bulleted text list
#  LIST.COLUMNS: n             # number of columns
#  LIST.IMAGE:                 # 'thumb' for thumbnails
#                              # 'medium' for medium pictures
#  LIST.BORDER:  n             # border size for image list
#  TITLE.IMAGE:  filename      # name of image for title.  Will create thumbdir/title.jpg
#                              # As a special case, will also create:
#                              #   thumbdir/title200.jpg   (200x150)
#                              #   thumbdir/title150.jpg   (150x300)
#                              # That behaviour may be generalized in the future.
#  TITLE.SIZES: size,size,     # List of sizes for title images
#  LINKSTYLE:                  # 'medium' for links to medium sized pics
#                              # 'full' for links to full (original) sized pictures
#                              # 'none' for no links at all
#                              # NOTE: if a .txt file exists for an image, that
#                              # overrides 'linkstyle' and a link will be made to
#                              # the page generated by that file and the template.
#  LINK.TARGET  _blank         # to display linked images in a new frame
#  SHOWSIZE:    0 or 1         # enable for "nnn files, totalling nnn bytes" message
#  SHOWNAME:    0 or 1         # enable to display link name in list
#  TEMPLATE:    filename       # path and filename to template file
#  IMAGES:      file,file,...  # list of filenames, or wildcards --   IMAGES: *.jpg
#  OUTPUT.FORMAT               # output format (jpeg, png) derives 'pnmtojpeg' or 'pnmtopng'
#                              # ^^ other than jpeg not yet supported
#  OUTPUT.SUFFIX               # e.g., 'jpeg' 'jpg' or 'png' derives 'thumb/output.jpeg'
#  OUTPUT.HTML                 # name of HTML output file (default: empty, for STDOUT)

use File::Basename;
use Image::Size;

use Getopt::Std;
getopt  ('tmc:p:T:u:');

BEGIN {
    push @INC, dirname($0); # So we can find our own modules
    # CVS revision
    ($version) = '$Revision: 1.1' =~ /([\d\.]+)/;
}

use relative_path;

#
# FIND PBM TOOLS
#

my $pbm = "/usr/local/netpbm/bin/";

unless (-e "${pbm}pnmscale") { $pbm = "/usr/bin/"; }
unless (-e "${pbm}pnmscale") { die "Can't find PBM tools."; }

# JPEG to PNM
my $djpeg = "djpeg";
unless (-e "${pbm}$djpeg") { $djpeg = "jpegtopnm"; }
unless (-e "${pbm}$djpeg") { die "Can't locate JPEG-to-PNM"; }
if ($djpeg eq "djpeg") { $djpeg .= ' -ppm ';}  # needs argument

# GIF to PNM
my $dgif = "giftopnm";
unless (-e "${pbm}$dgif") { die "Can't locate GIF-to-PNM"; }

# PNM to output format
my $cjpeg = "cjpeg";
unless (-e "${pbm}$cjpeg") { $cjpeg = "pnmtojpeg"; }
unless (-e "${pbm}$cjpeg") { die "Can't locate PNM-to-JPEG"; }

my $pamcut = "pamcut";
unless (-e "${pbm}$pamcut") { $pamcut = ''; }   # can't cut images


my $total_files = 0;
my $total_size =0;

my $debug = 1;

my %template_content = ('title' => '', 'contents' => '', 
			'h1' => '', 'h2' => '', 'h2a' => '', 'h3' => '', 'text' => '',
			thumb => 1, 'thumb.size' => '64x64', 'thumb.dir' => 'thumb',
			medium => 0, 'medium.size' => 640*480, 'medium.dir' => 'med',
			'list.type' => 'table', 'list.image' => 'thumb', 'list.columns' => '3',
			'list.border' => 1, 'title.image' => '', 'title.sizes' => '150x130,200x150',
			linkstyle => 'full', 'link.target' => '',
			showsize => 0, showname => 0, images => '',
			'output.format' => 'jpeg', 'output.suffix' => '.jpg', 'output.html' => '',
			'template.path' => '.',
			);

my %index_content = %template_content;

my $template = <<BLORT;
<HTML>
<!-- a basic template -->
<HEAD>
<TITLE>[:title:]</TITLE>
</HEAD>
<BODY>
<h1>[:h1:]</h1>
[:contents:]
</BODY>
</HTML>
BLORT

# -----

sub add_content {

    $index_content{'contents'} .= shift;

}

sub read_data {
    my $fname = shift;   # first arg is filename to read
    my %content = @_;   # optionally followed by default values (e.g., from main template)

    if (-e $fname) {
	print STDERR "reading $fname\n" if $debug;
	my $template;
	open ($template, "<", $fname);
	while (<$template>) {
	    my ($key, $value) = /^\s*([\w.]+)\s*:\s*(.*)$/;
	    $key = lc($key);
	    if ($value =~ /<<\s*(\w+)/) { # here-document
		my $stopword = $1;
		$content{$key} = '';
		while (<$template>) {
		    last if /$stopword/; # end of here-doc
		    $content{$key} .= $_;
		}
	    } else {
		if ($key eq 'include') {
		    if (! -e $value) {   # prefer files in local directory
			$value = $index_content{'template.path'} . $value; # also search template's directory
		    }
		    %content = read_data($value, %content);
		} else {
		    $content{$key} = $value;
		}
	    }
	}
	# close TEMPLATE;
    }
    return (%content);
}

sub replace_content {
    # replace placeholders in template with actual content
    my $output_text = shift;
    my %content = @_;
#    foreach (keys %content) {
#	$output_text =~ s/\[:$_:\]/$content{$_}/gsi;
#    }
    # permit conditionals
    $output_text =~ s/\[:(\w+)\?(\w+):\]/$content{$1}?$content{$1}:$content{$2}/gse;
    # regular text
    $output_text =~ s/\[:(\w+):\]/$content{$1}/gs;
    $output_text =~ s{\s*<h(\d)\b[^>]*>(\s|<br>)*</h\1>}{}gsi; # remove empty header tags
    return $output_text;
}

sub element_html {
    my $tag = shift;
    my %link_attrs = @_;

    my $retval = "<$tag " . join(' ', map {
	my $value = $link_attrs{$_};
	$value ? qq{$_="$value"} : '';
    } keys %link_attrs) . ">";
    return $retval;
}

sub scale_size {
    my $size_spec = shift;
    if ($size_spec =~ /x\s*(\d+)\s*[x|\*](\d+)/i) {
	# x100x100 = exactly 100x100 (may change aspect ratio)
	return "-xsize $1 -ysize $2 "; 
    } elsif ($size_spec =~ /(\d+)\s*[x|\*](\d+)/) {
	return "-xysize $1 $2 ";
    } else {
	return "-pixels $size_spec";
    }
}

sub pixel_count {
    my $size_spec = shift;
    if ($size_spec =~ /x\s*(\d+)\s*[x|\*](\d+)/i) {
	# x100x100 = exactly 100x100 (may change aspect ratio)
	return $1 * $2;
    } elsif ($size_spec =~ /(\d+)\s*[x|\*](\d+)/) {
	return $1 * $2;
    } else {
	return $size_spec;
    }
}


my $b = 1;

sub cutter_command {
    my ($size_spec, $pic_width, $pic_height) = @_;
    return '' unless length($pamcut);
    if  ($size_spec =~ /^\s*(\d+)\s*[x|\*]\s*(\d+)\s*$/) {

	print STDERR "current [$pic_width,$pic_height] ";
	my ($want_x, $want_y) = ($1, $2);
	my ($new_width, $new_height) = ($pic_width, $pic_height);

	my $xratio = $pic_width / $want_x;
	my $yratio = $pic_height / $want_y;
	print STDERR "($xratio, $yratio)\n";
	if ($xratio > $yratio) {
	    # truncate horizontal
	    $new_width = $pic_height / $want_y * $want_x;
	} else {
	    $new_height = $pic_width / $want_x * $want_y;
	}
	$new_height ||= 1;  # avoid /0 errors if can't find
	print STDERR " new [$new_width, $new_height]", $new_width / $new_height;

	my $xmargin = int($pic_width/2 - $new_width/2) ;
	my $ymargin = int($pic_height/2 - $new_height/2) ;
	print STDERR " margin={$xmargin, $ymargin}";
	# return " ${pbm}$pamcut -width $new_width -height $new_height -verbose | ";
	my $xx = $xmargin ? "-left $xmargin -right -$xmargin" : '';
	my $yy = $ymargin? "-top $ymargin -bottom -$ymargin" : '';
	$b++;
	return " ${pbm}$pamcut $xx $yy -verbose |  ";
    }
    return '';
}

sub resize_image {
    my ($from_image, $to_image, $to_size) = @_;

    my ($from_width, $from_height) = imgsize ($from_image); # from Image::Size
    my $scale_size = scale_size($to_size);
    my $current_width, $current_height;

    # If source image is already smaller than desired target, use source.
    ($current_width, $current_height) = imgsize ($from_image);
    return $from_image if (($current_width * $current_height) <= pixel_count($to_size));

    # Do not overwrite existing targets of larger size than we will create.
    if (-e $to_image) {
	($current_width, $current_height) = imgsize ($to_image);
	return $to_image if (($current_width * $current_height) > pixel_count($to_size));
    }
    # Create derivative picture, unless it exists and is newer than original file.
    unless (-e $to_image && -s $to_image && ((-M $to_image) < (-M $from_image))) {
#	my $picsize = scale_size($index_content{"${pic}.size"}, $width, $height);
	my $picsize = scale_size($to_size, $from_width, $from_height);
	print STDERR "creating $to_image with: $to_size\n" if $debug;
	my $cutter = cutter_command($to_size, $from_width, $from_height);
	my $mixdown = ($from_image =~ /.gif$/) ? "$pbm$dgif" : "$pbm$djpeg";
	my $command = "$mixdown $from_image | $cutter ${pbm}pnmscale $scale_size | $pbm$cjpeg > $to_image";
	print STDERR $command;
	system ($command);
    }
    return $to_image;

}

#
#
#  BEGIN MAIN PROGRAM
#
#

if ($opt_u) {
    open (TEMPLATE, "<", $opt_u);
    $template = '';
    $template .= $_ while (<TEMPLATE>);
    close TEMPLATE;

    # Replace href and src with relative paths
    $template =~ s/\b(href|src)\s*=\s*['"]([^'"]+)['"]/qq{$1="} . Path::relative($opt_u, $2) . qq{"}/ge;
    ($index_content{'template.name'}, $index_content{'template.path'}, $index_content{'template.suffix'}) = fileparse($opt_u, "\..*");
    %index_content = read_data('index.txt', %template_content);
}

$template_content{'h1'} = $index_content{'h1'};  # default first header

# override for named thumbnail and medium picture directories
$index_content{'thumb.dir'} = $opt_t if ($opt_t);
unless (-d $index_content{'thumb.dir'}) {
    mkdir ($index_content{'thumb.dir'});
}

if ($opt_m) {
    $index_content{'medium.dir'} = $opt_m;
    $index_content{'medium'} = 1;
}

if ($opt_s) {  # make medium pictures
    $index_content{'medium'} = 1;
    $index_content{'linkstyle'} = 'medium';
}

if ($opt_S) {  # make medium pictures in list, full sized for links
    $index_content{'medium'} = 1;
#    $index_content{'list.type'} = 'table';
    $index_content{'list.image'} = 'medium';
}
if ($opt_p) {
    $index_content{'medium.size'} = $opt_p;
}
if ($opt_c) {
#    $index_content{'list.type'} = 'table';
    $index_content{'list.columns'} = $opt_c;
    $index_content{'showsize'} = 0;
}
if ($opt_T) {
    $index_content{'thumb.size'} = "${opt_T}x${opt_T}";
}

if ($index_content{'medium'}) {
    unless (-d $index_content{'medium.dir'}) {
	mkdir ($index_content{'medium.dir'});
    }
}

my $column = 0;
if (lc($index_content{'list.type'}) eq 'table') {
    add_content ("<TABLE><TR>\n");
} elsif (lc($index_content{'list.type'}) eq 'ul') {
    add_content ("<UL>\n");
}

# List of images to process
my @file_list;
if ($index_content{'images'}) {
    @file_list = glob($index_content{'images'});
    my $x = join('|', @file_list);
} else {
    @file_list = <>;   # from STDIN
}

foreach (@file_list) {
    chomp;
    s/\*//;
    my $list_pic;
    my $linked_pic;
    my $link_to;
    my $actual_pic = $_;
    my $linkname_text;
    my $size_text;
    my %link_attrs;

    my ($from_file_name,$from_file_path,$from_file_suffix) = fileparse($_,'\..*');

    if ($from_file_suffix =~ /\.(jpe?g|gif)$/i) {

	$index_content{'full.name'} = $_;

	my $text_file = "${from_file_name}.txt";    # input text configuration for this picture
	# Text file also could be in picture source directory
	$text_file = "$from_file_path/$text_file" if ((! -e $text_file) && $from_file_path);

	my $html_file = "${from_file_name}.html";   # output HTML, into current directory

	foreach my $pic (qw{medium thumb}) {   # create selected derivative pictures
	    if ($index_content{$pic}) {
		my $source = $index_content{'full.name'};
		my $target = "${pic}.name";
		my $suggested_target_name = $index_content{"${pic}.dir"} . "/${from_file_name}$index_content{'output.suffix'}";

		# Optimization: If creating both, use medium pic from 1st pass to create thumbnail.
		if (($pic eq 'thumb') && ($index_content{'medium'})) {
		    $source = $index_content{"medium.name"};
		}
		$index_content{$target} = resize_image($source, $suggested_target_name, $index_content{"${pic}.size"});
	    }
	}

	$list_pic   = $index_content{$index_content{'list.image'} . '.name'};
	$linked_pic = $index_content{lc($index_content{'linkstyle'}) . '.name'};
	$link_to = $linked_pic;   # by default, we link to the picture

	if (-e $text_file) {
	    my %file_content = read_data($text_file, %template_content);

	    $file_content{'contents'} = qq{<IMG SRC="$linked_pic">};
	    $link_attrs{'rel'} = "child";
	    $link_attrs{'title'} = $file_content{'h1'};
	    
	    my $output_text = replace_content($template, %file_content);
	    print STDERR "writing $html_file\n" if $debug;
	    open HTML, ">", $html_file;
	    print HTML $output_text;
	    close HTML;
	    $link_to = $html_file;  # override list's link to be this HTML file.
	}
    }

    if ($index_content{'showsize'}) {
	my $size = -s $linked_pic;
	my $k_size = int(($size + 512) / 1024);
	$total_size += $size;
	$total_files++;
	$size_text = " (${k_size}K)";
    }
    if ($index_content{'showname'}) {
	$linkname_text = "&nbsp;&nbsp;$index_content{'full.name'}"; # link_to";
    }

    $link_attrs{'href'} = $link_to;
    $link_attrs{'target'} = $index_content{'link.target'};
    my $a_text = $link_attrs{'href'} ? element_html('a', %link_attrs) : '';  # optional link
    my $a_end = $a_text ? '</a>' : '';

    my $img_text = element_html('img', src=> $list_pic, border => $index_content{'list.border'});
    my $entry_text = "$a_text$img_text$linkname_text$size_text$a_end";

    if (lc($index_content{'list.type'}) eq 'table') {
	add_content ("<TD align='center' valign='middle'>$entry_text</TD>\n");
	my $new_row = 1;
	if ($index_content{'list.columns'}) {
	    $new_row = 0 if (++$column < $index_content{'list.columns'});
	}
	if ($new_row) {
	    add_content( "</TR>\n<TR>\n");
	    $column = 0;
	}
    } elsif (($index_content{'list.type'}) eq 'ul') {
	add_content("<LI>$entry_text</LI>\n");
    } else {
	add_content("<P>$entry_text</P>\n");
    }
}

if ($index_content{'title.image'}) {
#    my $source = $index_content{''} . $index_content{'title.image'};
    my $source = $index_content{'title.image'};
    foreach my $size (split(',', $index_content{'title.sizes'})) {
	$size =~ s/\s+//g;       # remove spaces
	my $size_spec = $size;
	$size_spec =~ s/x\d+//;  # 200x150 -> 200
	my $target = $index_content{"thumb.dir"} . "/title_$size_spec$index_content{'output.suffix'}";
	resize_image($source, $target, $size);
    }
}

if (lc($index_content{'list.type'}) eq 'table') {
    add_content ("</TABLE>\n");
} elsif (lc($index_content{'list.type'}) eq 'ul') {
    add_content ("</UL>\n");
}

add_content("$total_files files, totalling $total_size bytes.\n") if ($index_content{'showsize'});

if ($index_content{'output.html'}) {
    open OUTFILE, ">", $index_content{'output.html'} or die "Can't open output file";
    print OUTFILE replace_content($template, %index_content);
    close OUTFILE;
} else {
    print replace_content($template, %index_content);
}

exit 1;
